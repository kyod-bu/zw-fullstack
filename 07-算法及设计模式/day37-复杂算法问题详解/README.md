# 贪心算法与动态规划

## 贪心算法

**贪心算法**是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法不是对所有问题都能得到整体最优解，主要的难点是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

### 买卖股票问题

有一个股市大盘，每天会展示当前的股票价格，如果我们同一时刻只能有一笔交易（要再买股票前必须先卖出）我们应该以怎么样的策略来买卖股票？才能使我们的整体收益最大呢？

分析问题的两个注意点：

* 股票必须先买入，之后才能卖出
* 同一时刻只能有一笔交易，也就是必须先卖出之后，才能买入股票

例如用一个数组 array 来表示股票的情况，数组中的每个元素代表着股票价格，数组中的索引 n 代表着第 n+1 天的情况。

以 array 为 [1, 2, 3, 4, 5] 为例，在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。

以 array 为 [5, 4, 3, 2, 1] 为例，无论在哪天买入，哪天卖出，我们都会亏损，所以最好的策略就是我们不买卖股票，收益为 0。

以 array 为 [7, 1, 5, 3, 6, 4] 为例，我们就需要绘制图像，通过图像来对比出整体流程中的**波峰**和**波谷**，添加每个波峰和波谷的差值。

![买卖股票](./img/买卖股票.png)

如上图所示，我们在第2天以1元买入，在第3天以5元卖出，在第4天以3元买入，在第5天以6元卖出，整体收益最大，最大收益为4+3=7元。

对于我们的代码来讲，我们如何判断出当前的波峰和波谷呢？事实上我们并不需要那么复杂的寻找波峰和波谷，对于波峰和波谷来说，主要趋势是上涨的，那么对于波峰和波谷之间的每一次上涨，最终他们的幅度都是相同的。

![买卖股票2](./img/买卖股票2.png)

以上图为例，第3天是一个波谷，第6天是一个波峰，对于这一次的上涨来说，我们的收益为 7-2=5，也就是图中 D 这条线代表的高度，但同样的，对于每一天来说，他们都是一个小的上涨，只要后一天股票的价格比前一天高，那么最终在这个连续的周期内，最终股票的价格的幅度都是确定的。例如，第3天买入第4天卖出，那么这一段收益为1，第4天买入第5天卖出，那么这一段收益为3，第5天买入第6天卖出，这一段收益为1，加起来的收益为 1+3+1，总收益还是 5，与实际波峰波谷计算的结果完全相同。

所以对于这个问题我们能快速的转化和分析出问题的结果，那就是，对于这个股票买卖的问题，只要后一天比前一天的价格高，那么我们就计算他们的差值，最终加和这部分上升的利润就是我们的结果。

我们也能轻易的写出来我们的代码：

```js
var maxProfit = function(prices) {
    var count = 0;
    for(var i=1; i<prices.length; i++) {
        var price = prices[i];
        var prevPrice = prices[i - 1];
        if (price > prevPrice) {
            count += price - prevPrice;
        }
    }
    return count;
}
```

在这个例子中，我们也可以利用反证法证明我们的贪心算法的正确性，也就是假设我们的算法不是最优解，因为我们无法反证为真，那么当前的算法即为为优解：

假设“贪心算法”得到的解不是最优解，即我们对于股票买卖还能够找到一个解法比我们上面的“贪心算法”过程得到的利润还多。

对于每两天之间的利润差，后一天价格减去前一天价格，只会有**负数、0、正数**三种情况，我们的贪心解法，正是每次加和时都使用正数的情况。

1. 如果可行解在 “贪心算法” 的基础上，选择了差为 0 的项，得到的结果与 “贪心算法” 得到的结果一样，因此加上差分为 0 的项不会比 “贪心算法” 得到的结果更好；
2. 如果可行解在 “贪心算法” 的基础上，选择了差分为 负数 的项，加上一个负数得到的结果一定比 “贪心算法” 得到的结果要少；
3. 如果可行解在 “贪心算法” 的基础上，去掉了任何一个差分为 正数 的项，同上，得到的结果一定比 “贪心算法” 得到的结果要少，因此，“贪心算法” 的所有组成项不能删除任何一个。

综上，除了 “贪心算法” 以外，找不到一个更优的解法，因此 “贪心算法” 就是最优解。

这就是一道简单的入门级别题目，使用贪心算法的思路，能让我们快速的把复杂问题简化，每一天只考虑在当前状态下的最优解，最终将每一步的最优解进行合并的这样一种思路，从证明和结果来看，对于本题都是一个合适的解法，最终的代码逻辑也比较简单。

对于大部分的问题，贪心算法通常都不能找出最佳解，因为他们一般没有测试所有可能的解。贪心算法容易**过早做决定**，因而没法达到最佳解。

### 电梯问题

假设我们有一个电梯，我们需要从底部爬到顶部。对于电梯他有如下的一个设定。如果我们到了某个楼层，那么我们最远可以直接向上传送当前元素的结果。我们要做的就是判断是不是能够到达电梯顶部。

简单来说，我们给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

以数组 array [2, 3, 1, 1, 4] 为例，我们可以先跳1步，从位置 0 到达位置 1，然后再从位置 1 跳 3 步到达最后一个位置。

以数组 array [3, 2, 1, 0, 4] 为例，总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0，所以你永远不可能到达最后一个位置。

我们可以使用贪心的方法解决这个问题。设想一下，对于数组中的任意一个位置，我们如何判断他是否可以到达？

根据题目的描述，只要存在一个位置 x，他本身可以到达，并且他跳跃的最大长度为 x + nums[x] ，这个值大于等于 y，即 x + nums[x] > y，那么位置 y 也可以到达。

换句话说，对于每一个可以到达的位置 x，他使得 x+1 ~ x+nums[x] 的位置都可达。

这样一来，我们依次遍历数组中的每一个位置，并实时维护最远到达的位置。对于当前遍历到的位置 x，如果他在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新 最远可以到达的位置。

在遍历的过程中，如果 最远可以到达的位置 大于等于组组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 true。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 false。

以 [2, 3, 1, 1, 4] 为例：

我们一开始在位置 0，可以跳跃的最大长度为 2，因此最远可以到达的位置被更新为 2；

我们遍历到位置 1，由于 1 <= 2，因此位置 1 可达。我们用 1 加上 它可以跳跃的最大长度 3，将最远可以到达的位置更新为 4。由于 4 大于等于 最后一个位置 4，因此我们直接返回 true。

我们再来看看题目中的示例二：

以 [3, 2, 1, 0, 4] 为例：

我们一开始在位置 0，可以跳跃的最大长度为 3，因此最远可以到达的位置被更新为 3；

我们遍历到位置 1，由于 1 <= 3，因此位置 1 可达。加上 它可以跳跃的最大长度 2，没有超过最远可以到达的位置；

位置2、位置3 同理，最远可以到达的位置不会被更新；

我们遍历到位置4，由于 4 > 3，因此位置4不可达，我们也就不考虑它可以跳跃的最大长度了。

在遍历完成之后，位置4仍然不可达，因此我们返回 false。

```js
function canJump(nums) {
    var length = nums.length;
    var maxPos = 0;
    for(var i=0; i<length; i++) {
        if (i <= maxPos) {
            maxPos = Math.max(maxPos, i + nums[i]);
            if (maxPos >= length -1) {
                return true;
            }
        }
    }
    return false;
}
```

如果我们给这个题目加一些限制，比如使用最少的跳跃次数跳跃到数组的最后一个位置，这道题目就变复杂了很多。

在上面的例子中，我们通过每次计算能够到达的最远距离来判断我们是否能到达数组的最后一个位置。但这次加上了一个限制，是否能够**用最小的跳跃次数**达到结果。

以数组 array [2, 3, 1, 1, 4] 为例，跳到最后一个位置的最小跳跃长度是 2。我们可以从下标为 0 跳到下标为 1 的位置，跳1步，然后跳 3 步到达数组的最后一个位置。

```js
function jumpSteps(nums) {
    var length = nums.length;
    var end = 0;
    var maxPosition = 0;
    var steps = 0;
    for(var i=0; i<length-1; i++) {
        maxPosition = Math.max(maxPosition, i + nums[i]);
        if (i == end) {
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}
```

#### 复杂度分析

* 时间复杂度：$O(n)$ ，其中 n 是数组长度。
* 空间复杂度：$O(1)$ 

## 动态规划

### 爬楼梯问题

### 动态规划算法理论

### 斐波那契数列

### 兑换硬币问题

### 买卖股票问题
