# 【JS内功修炼】Promise详解

## Promise详解

### 1 为什么需要Promise

JavaScript是一门单线程语言，所以早期我们解决异步的场景时，大部分情况都是通过回调函数来进行。

例如在浏览器中发送**ajax**请求，就是常见的一个异步场景，发送请求后，一段时间服务端响应之后我们才能拿到结果。如果我们希望在异步结束之后执行某个操作，就只能通过回调函数这样的方式进行操作。

```javascript
var dynamicFunc = function(cb) {
    setTimeout(function() {
        cb();
    }, 1000);
}
dynamicFunc(function() {console.log(123)});
```

例如上面的这个例子，这里的dynamicFunc就是一个异步函数，里面执行的setTimeout会在1s之后调用传入的cb函数。按照上面的调用方式，最终1s之后，会打印123这个结果。

同样的，如果后续还有内容需要在异步函数结束时输出的话，就需要多个异步函数进行嵌套，非常不利于后续的维护。

```javascript
setTimeout(function() {
  console.log(123);
  setTimeout(function() {
    console.log(321);
    // ...
  }, 2000);
}, 1000);
```

为了能使回调函数以更优雅的方式进行调用，在ES6中js产生了一个名为promise的新规范，他让异步操作变得近乎“同步化”。

### 2 Promise是如何使用的

在支持ES6的高级浏览器环境中，我们通过**new Promise()**即可构造一个**promise**实例。

这个构造函数接受一个函数，分别接受2个参数：resolve和reject，代表着我们需要改变当前实例的状态到“已完成”或是“已拒绝”。

```javascript
function promise1() {
    return new Promise(function (resolve, reject) {
        // 定义异步的内容
        setTimeout(function () {
            console.log('1s 后输出');
            //输出完成后，调用函数传入的resolve函数，将该promise实例标为已完成，当前promise串行继续执行
            resolve();
        }, 1000);
    });
}
```

```javascript
function promise2() {
    return new Promise(function (resolve) {
        setTimeout(function() {
            console.log('2s 后输出');
            resolve();
        }, 2000);
    });
}
```

上面的2个promise实例，串联起来即可写为：<code>promise1().then(function() { return promise2(); });</code>

也可以简写为：<code>promise1().then(promise2);</code>

浏览器中执行之后，即可看到，1s之后出现**1s 后输出**字样，再经过2s出现**2s 后输出**字样。在这个例子中，我们能看到，当前promise如果状态变为已完成（执行了resolve方法），那么就会去执行then方法中的下一个promise函数。

同样的，如果我们的promise变为已拒绝状态（执行了reject方法），那么就会进入后续的异常处理函数中。

```javascript
function promise3() {
    return new Promise(function (resolve, reject) {
        var random = Math.random() * 10; // 随机一个1～10的数字
        setTimeout(function () {
            if (random >= 5) {
                resolve(random);
            } else {
                reject(random);
            }
        }, 1000);
    });
}

var onResolve = function (val) {
    console.log('已完成：输出的数字是 ', val);
};

var onReject = function (val) {
    console.log('已拒绝：输出的数字是 ', val);
}

// promise的then也可以接受2个函数，第一个参数为resolve后执行，第二个函数为reject后执行
promise3().then(onResolve, onReject);

// 也可以通过 .catch 方法拦截状态变为已拒绝时的 promise
promise3().catch(onReject).then(onResolve);

// 也可以通过 try catch 进行拦截状态变为已拒绝时的 promise
try {
    promise3().then(onResolve);
} catch (e) {
    onReject(e);
}
```

这个例子使用了三种方式拦截最终变为【已拒绝】状态的promise，分别是：

1. 使用 then 的第二个参数
2. 使用 .catch 方法捕获前方promise抛出的异常
3. 使用 try catch 拦截代码块中 promise 抛出的异常

同时我们还可以发现，在改变promise状态时，调用resolve和reject函数的时候，也可以给下一步then中执行的函数传递参数。这个例子中我们把随机生成的数字传给了resolve和reject函数，我们也就能在then中执行函数的时候拿到这个值。

总结一下本小节的内容：

1. promise会有三种状态
2. ES6中的Promise构造函数，我们构造之后需要传入一个函数
3. 通过 .then 方法
4. 已拒绝的 promise，后续可以通过 .catch 方法或是 .then 方法的第二个参数或是 try catch 进行捕获。

### 3 封装异步操作为 promise

我们可以