# 【JS内功修炼】Promise详解

## 1 Promise详解

### 1.1 为什么需要Promise

JavaScript是一门单线程语言，所以早期我们解决异步的场景时，大部分情况都是通过回调函数来进行。

例如在浏览器中发送**ajax**请求，就是常见的一个异步场景，发送请求后，一段时间服务端响应之后我们才能拿到结果。如果我们希望在异步结束之后执行某个操作，就只能通过回调函数这样的方式进行操作。

```javascript
var dynamicFunc = function(cb) {
    setTimeout(function() {
        cb();
    }, 1000);
}
dynamicFunc(function() {console.log(123)});
```

例如上面的这个例子，这里的dynamicFunc就是一个异步函数，里面执行的setTimeout会在1s之后调用传入的cb函数。按照上面的调用方式，最终1s之后，会打印123这个结果。

同样的，如果后续还有内容需要在异步函数结束时输出的话，就需要多个异步函数进行嵌套，非常不利于后续的维护。

```javascript
setTimeout(function() {
  console.log(123);
  setTimeout(function() {
    console.log(321);
    // ...
  }, 2000);
}, 1000);
```

为了能使回调函数以更优雅的方式进行调用，在ES6中js产生了一个名为promise的新规范，他让异步操作变得近乎“同步化”。

### 1.2 Promise是如何使用的

在支持ES6的高级浏览器环境中，我们通过**new Promise()**即可构造一个**promise**实例。

这个构造函数接受一个函数，分别接受2个参数：resolve和reject，代表着我们需要改变当前实例的状态到“已完成”或是“已拒绝”。

```javascript
function promise1() {
    return new Promise(function (resolve, reject) {
        // 定义异步的内容
        setTimeout(function () {
            console.log('1s 后输出');
            //输出完成后，调用函数传入的resolve函数，将该promise实例标为已完成，当前promise串行继续执行
            resolve();
        }, 1000);
    });
}
```

```javascript
function promise2() {
    return new Promise(function (resolve) {
        setTimeout(function() {
            console.log('2s 后输出');
            resolve();
        }, 2000);
    });
}
```

上面的2个promise实例，串联起来即可写为：<code>promise1().then(function() { return promise2(); });</code>

也可以简写为：<code>promise1().then(promise2);</code>

浏览器中执行之后，即可看到，1s之后出现**1s 后输出**字样，再经过2s出现**2s 后输出**字样。在这个例子中，我们能看到，当前promise如果状态变为已完成（执行了resolve方法），那么就会去执行then方法中的下一个promise函数。

同样的，如果我们的promise变为已拒绝状态（执行了reject方法），那么就会进入后续的异常处理函数中。

```javascript
function promise3() {
    return new Promise(function (resolve, reject) {
        var random = Math.random() * 10; // 随机一个1～10的数字
        setTimeout(function () {
            if (random >= 5) {
                resolve(random);
            } else {
                reject(random);
            }
        }, 1000);
    });
}

var onResolve = function (val) {
    console.log('已完成：输出的数字是 ', val);
};

var onReject = function (val) {
    console.log('已拒绝：输出的数字是 ', val);
}

// promise的then也可以接受2个函数，第一个参数为resolve后执行，第二个函数为reject后执行
promise3().then(onResolve, onReject);

// 也可以通过 .catch 方法拦截状态变为已拒绝时的 promise
promise3().catch(onReject).then(onResolve);

// 也可以通过 try catch 进行拦截状态变为已拒绝时的 promise
try {
    promise3().then(onResolve);
} catch (e) {
    onReject(e);
}
```

这个例子使用了三种方式拦截最终变为【已拒绝】状态的promise，分别是：

1. 使用 then 的第二个参数
2. 使用 .catch 方法捕获前方promise抛出的异常
3. 使用 try catch 拦截代码块中 promise 抛出的异常

同时我们还可以发现，在改变promise状态时，调用resolve和reject函数的时候，也可以给下一步then中执行的函数传递参数。这个例子中我们把随机生成的数字传给了resolve和reject函数，我们也就能在then中执行函数的时候拿到这个值。

总结一下本小节的内容：

1. promise会有三种状态：【进行中】【已完成】【已拒绝】，进行中状态可以更改为已完成或已拒绝，已经更改过状态后，无法继续更改（例如，从已完成改为已拒绝）。
2. ES6中的Promise构造函数，我们构造之后需要传入一个函数，他接受2个函数参数，执行第一个参数之后就会改变当前promise为“已完成”状态，执行第二个参数之后就会变为“已拒绝”状态。
3. 通过 .then 方法，即可在上一个promise达到已完成时继续执行下一个函数或promise。同时通过resolve或reject时传入参数，即可给下一个函数或promise传入初始值。
4. 已拒绝的 promise，后续可以通过 .catch 方法或是 .then 方法的第二个参数或是 try catch 进行捕获。

### 1.3 封装异步操作为 promise

我们可以将任何接受回调的函数封装为一个promise，下面举几个例子来说明：

```javascript
// 原函数
function dynamicFunc(cb) {
  setTimeout(function() {
    console.log('1s 后显示');
    cb();
  }, 1000);
}

var callback = function() {
  console.log('在异步结束后 log');
}

// 用传入回调函数的方式执行
dynamicFunc(callback);
```

上面的例子就是最传统的，使用传入回调函数的方式在异步结束后执行函数。我们可以通过封装promise的方式，将这个异步函数变为promise

```javascript
function dynamicFuncAsync() {
  return new Promise(function(resolve) {
    setTimeout(function(){
      console.log('1s 后显示');
      resolve();
    });
  });
}

var callback = function() {
  console.log('在异步结束后 log');
}

dynamicFuncAsync().then(function() { callback(); });
```

再举一个例子，发送ajax请求也可以进行封装：

```javascript
function ajax(url, success, fail) {
  var client = new XMLHttpRequest();
  client.open("GET", url);
  client.onreadystatechange = function() {
    if(this.readyState !== 4) {
      return;
    }
    if(this.status === 200) {
      success(this.response);
    } else {
      fail(new Error(this.statusText));
    }
  };
  client.send();
};

ajax('/ajax.json', function(){console.log('成功')}, function(){console.log('失败')});
```

我们可以看到，调用ajax方法时需要传入success和fail的回调函数进行调用。我们可以不传入回调函数，通过封装promise的方式，在原来的执行回调函数的地方更改当前promise的状态，就可以通过链式调用。

```javascript
function ajaxAsync(url) {
  return new Promise(function(resolve, reject) {
    var client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = function() {
      if(this.readyState !== 4) {
        return;
      }
      if(this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    client.send();
  });
};

ajaxAsync('/ajax.json')
  .catch(function() {
    console.log('失败');
  })
  .then(function() {
    console.log('成功');
  })
```

总结一下当前小节：

1. 我们可以轻松的把任何一个函数或者是异步函数改为promise，尤其是异步函数，改为promise之后即可进行链式调用，增强可读性。
2. 将带有回调函数的异步改为promise也很简单，只需要在内部实例话promise之后，在原来执行回调函数的地方执行对应的更改promise状态的函数即可。

### 1.4 promise 规范解读

任何符合promise规范的对象或函数都可以成为promise，promise A plus规范地址：<https://promisesaplus.com>

上面我们熟悉了整体promise的用法