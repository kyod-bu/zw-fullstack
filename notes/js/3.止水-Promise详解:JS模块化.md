# 【JS内功修炼】Promise详解

## 1 Promise 详解

### 1.1 为什么需要 Promise

JavaScript是一门单线程语言，所以早期我们解决异步的场景时，大部分情况都是通过回调函数来进行。

例如在浏览器中发送**ajax**请求，就是常见的一个异步场景，发送请求后，一段时间服务端响应之后我们才能拿到结果。如果我们希望在异步结束之后执行某个操作，就只能通过回调函数这样的方式进行操作。

```javascript
var dynamicFunc = function(cb) {
    setTimeout(function() {
        cb();
    }, 1000);
}
dynamicFunc(function() {console.log(123)});
```

例如上面的这个例子，这里的dynamicFunc就是一个异步函数，里面执行的setTimeout会在1s之后调用传入的cb函数。按照上面的调用方式，最终1s之后，会打印123这个结果。

同样的，如果后续还有内容需要在异步函数结束时输出的话，就需要多个异步函数进行嵌套，非常不利于后续的维护。

```javascript
setTimeout(function() {
  console.log(123);
  setTimeout(function() {
    console.log(321);
    // ...
  }, 2000);
}, 1000);
```

为了能使回调函数以更优雅的方式进行调用，在ES6中js产生了一个名为promise的新规范，他让异步操作变得近乎“同步化”。

### 1.2 Promise 是如何使用的

在支持ES6的高级浏览器环境中，我们通过**new Promise()**即可构造一个**promise**实例。

这个构造函数接受一个函数，分别接受2个参数：resolve和reject，代表着我们需要改变当前实例的状态到“已完成”或是“已拒绝”。

```javascript
function promise1() {
    return new Promise(function (resolve, reject) {
        // 定义异步的内容
        setTimeout(function () {
            console.log('1s 后输出');
            //输出完成后，调用函数传入的resolve函数，将该promise实例标为已完成，当前promise串行继续执行
            resolve();
        }, 1000);
    });
}
```

```javascript
function promise2() {
    return new Promise(function (resolve) {
        setTimeout(function() {
            console.log('2s 后输出');
            resolve();
        }, 2000);
    });
}
```

上面的2个promise实例，串联起来即可写为：<code>promise1().then(function() { return promise2(); });</code>

也可以简写为：<code>promise1().then(promise2);</code>

浏览器中执行之后，即可看到，1s之后出现**1s 后输出**字样，再经过2s出现**2s 后输出**字样。在这个例子中，我们能看到，当前promise如果状态变为已完成（执行了resolve方法），那么就会去执行then方法中的下一个promise函数。

同样的，如果我们的promise变为已拒绝状态（执行了reject方法），那么就会进入后续的异常处理函数中。

```javascript
function promise3() {
    return new Promise(function (resolve, reject) {
        var random = Math.random() * 10; // 随机一个1～10的数字
        setTimeout(function () {
            if (random >= 5) {
                resolve(random);
            } else {
                reject(random);
            }
        }, 1000);
    });
}

var onResolve = function (val) {
    console.log('已完成：输出的数字是 ', val);
};

var onReject = function (val) {
    console.log('已拒绝：输出的数字是 ', val);
}

// promise的then也可以接受2个函数，第一个参数为resolve后执行，第二个函数为reject后执行
promise3().then(onResolve, onReject);

// 也可以通过 .catch 方法拦截状态变为已拒绝时的 promise
promise3().catch(onReject).then(onResolve);

// 也可以通过 try catch 进行拦截状态变为已拒绝时的 promise
try {
    promise3().then(onResolve);
} catch (e) {
    onReject(e);
}
```

这个例子使用了三种方式拦截最终变为【已拒绝】状态的promise，分别是：

1. 使用 then 的第二个参数
2. 使用 .catch 方法捕获前方promise抛出的异常
3. 使用 try catch 拦截代码块中 promise 抛出的异常

同时我们还可以发现，在改变promise状态时，调用resolve和reject函数的时候，也可以给下一步then中执行的函数传递参数。这个例子中我们把随机生成的数字传给了resolve和reject函数，我们也就能在then中执行函数的时候拿到这个值。

总结一下本小节的内容：

1. promise会有三种状态：【进行中】【已完成】【已拒绝】，进行中状态可以更改为已完成或已拒绝，已经更改过状态后，无法继续更改（例如，从已完成改为已拒绝）。
2. ES6中的Promise构造函数，我们构造之后需要传入一个函数，他接受2个函数参数，执行第一个参数之后就会改变当前promise为“已完成”状态，执行第二个参数之后就会变为“已拒绝”状态。
3. 通过 .then 方法，即可在上一个promise达到已完成时继续执行下一个函数或promise。同时通过resolve或reject时传入参数，即可给下一个函数或promise传入初始值。
4. 已拒绝的 promise，后续可以通过 .catch 方法或是 .then 方法的第二个参数或是 try catch 进行捕获。

### 1.3 封装异步操作为 promise

我们可以将任何接受回调的函数封装为一个promise，下面举几个例子来说明：

```javascript
// 原函数
function dynamicFunc(cb) {
  setTimeout(function() {
    console.log('1s 后显示');
    cb();
  }, 1000);
}

var callback = function() {
  console.log('在异步结束后 log');
}

// 用传入回调函数的方式执行
dynamicFunc(callback);
```

上面的例子就是最传统的，使用传入回调函数的方式在异步结束后执行函数。我们可以通过封装promise的方式，将这个异步函数变为promise

```javascript
function dynamicFuncAsync() {
  return new Promise(function(resolve) {
    setTimeout(function(){
      console.log('1s 后显示');
      resolve();
    });
  });
}

var callback = function() {
  console.log('在异步结束后 log');
}

dynamicFuncAsync().then(function() { callback(); });
```

再举一个例子，发送ajax请求也可以进行封装：

```javascript
function ajax(url, success, fail) {
  var client = new XMLHttpRequest();
  client.open("GET", url);
  client.onreadystatechange = function() {
    if(this.readyState !== 4) {
      return;
    }
    if(this.status === 200) {
      success(this.response);
    } else {
      fail(new Error(this.statusText));
    }
  };
  client.send();
};

ajax('/ajax.json', function(){console.log('成功')}, function(){console.log('失败')});
```

我们可以看到，调用ajax方法时需要传入success和fail的回调函数进行调用。我们可以不传入回调函数，通过封装promise的方式，在原来的执行回调函数的地方更改当前promise的状态，就可以通过链式调用。

```javascript
function ajaxAsync(url) {
  return new Promise(function(resolve, reject) {
    var client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = function() {
      if(this.readyState !== 4) {
        return;
      }
      if(this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    client.send();
  });
};

ajaxAsync('/ajax.json')
  .catch(function() {
    console.log('失败');
  })
  .then(function() {
    console.log('成功');
  })
```

总结一下当前小节：

1. 我们可以轻松的把任何一个函数或者是异步函数改为promise，尤其是异步函数，改为promise之后即可进行链式调用，增强可读性。
2. 将带有回调函数的异步改为promise也很简单，只需要在内部实例话promise之后，在原来执行回调函数的地方执行对应的更改promise状态的函数即可。

### 1.4 promise 规范解读

任何符合promise规范的对象或函数都可以成为promise，promise A plus规范地址：<https://promisesaplus.com>

上面我们熟悉了整体promise的用法，我们知道了如何去创建一个promise，如何去使用它，后面我们也熟悉了如何去改造回调函数到promise。本小节我们详细过一遍 **promise A+** 规范，从规范层面明白promise使用过程中的细节。

#### 1.4.1 术语

* **Promise：**promise是一个拥有 `then` 方法的对象或函数，其行为符合本规范。
* **具有then方法（thenable）：**是一个定义了 `then` 方法的对象或函数。
* **值（value）：**指任何 JavaScript 的合法值（包括 `undefined`，`thenable` 和 `promise`）。
* **异常（exception）：**是使用 `throw` 语句抛出的一个值。
* **原因（reason）：**表示一个 promise 的拒绝原因。

#### 1.4.2 要求

##### 1.4.2.1 promise 的状态

一个 promise 的当前状态必须为以下3种状态中的一种：**等待态（Pending）**、**已完成（Fullfilled）**、**已拒绝（Reject）**。

* 处于等待态时，promise 需满足以下条件：可以变为【已完成】或【已拒绝】
* 处于已完成时，promise 需满足以下条件：1.不能迁移至其他任何状态，2.必须拥有一个**不可变**的**值**
* 处于已拒绝时，promise 需满足以下条件：1. 不能迁移至其他任何状态，2.必须拥有一个**不可变**的**原因**

##### 1.4.2.2 必须有一个 then 方法

一个 promise 必须提供一个 `then` 方法以访问其当前值和原因。

promise 的 `then` 方法接受2个参数：`promise.then(onFullfilled, onRejected)` 它们都是可选参数，同时它们都是函数，如果 `onFullfilled` 或 `onRejected` 不是函数，则需要忽略它们。

* 如果 `onFullfilled` 是一个函数
  * 当 `promise` 执行结束后，其必须被调用，其第一个参数为 `promise` 的结果
  * 在 `promise` 执行结束前，其不可被调用
  * 其调用次数不可超过 1次
* 如果 `onRejected` 是一个函数
  * 当 `promise` 被拒绝执行后，其必须被调用，其第一个参数为 `promise` 的原因
  * 在 `promise` 被拒绝执行前，其不可被调用
  * 其调用次数不可超过 1次
* 在执行上下文堆栈仅包含平台代码之前，不得调用 `onFullfilled` 或`onRejected`
* `onFullfilled` 和 `onRejected` 必须被作为普通函数调用（即非实例化调用，这样函数内部 `this` 非严格模式下指向window）
* `then` 方法可以被同一个 `promise` 调用多次
  * 当 `promise` 成功执行时，所有 `onFullfilled` 需按照其注册顺序依次回调
  * 在 `promise` 被拒绝执行时，所有 `onRejected` 需按照其注册顺序依次回调
* `then` 方法必须返回一个 `promise` 对象 `promise2 = promise1.then(onFullfilled, onRejected);`
  * 只要 `onFullfilled` 或者 `onRejected` 返回一个值 `x`，promise2 都会进入 onFullfilled 状态
  * 如果 `onFullfilled` 或者 `onRejected` 抛出一个异常 `e`，则 promise2 必须拒绝执行，并返回拒绝原因
  * 如果 `onFullfilled` 不是函数，且 `promise1` 状态变为已完成， `promise2` 必须成功执行并返回相同的值
  * 如果 `onRejected` 不是函数，且 `promise1` 状态变为已拒绝， `promise2` 必须执行拒绝回调并返回相同的原因

```javascript
var promise1 = new Promise((resolve, reject) => { reject(); });
promise1
  .then(null, function() {
    return 123;
  })
  .then(null, null)
  .then(null, null)
  .then(
    () => {
      console.log('promise2 已完成');
    }, 
    () => {
      console.log('promise2 已拒绝');
    });
```

#### 1.4.3 promise 的解决过程

​		**Promise 解决过程**是一个抽象的操作，其需输入一个 `promise` 和一个值，我们表示为 `[[Resolve]](promise, x)` （这句话的意思就是把 promise resolve 了，同时传入 x 作为值）

```javascript
promise.then(function(x) {
  console.log('会执行这个函数，同时传入 x 变量的值', x);
});
```

如果 `x` 有 `then`方法且看上去像一个 Promise，解决程序即尝试使 `promise` 接受 `x` 的状态；否则，其用 `x` 的值来执行 `promise` 

* 如果 `promise` 和 `x` 指向同一对象，以 `TypeErroe` 为据因拒绝执行 `promise`

* 如果 x 为 promise

  * 如果 `x` 处于等待态，`promise` 需保持为等待态直至 `x` 被执行或拒绝
  * 如果 `x` 处于执行态，用相同的值执行 `promise`
  * 如果 `x` 处于拒绝态，用相同的据因拒绝 `promise` 

  ```javascript
  var promise1 = function() {
    return new Promise(function(resolve) {
      setTimeout(function() {
        console.log(1);
        resolve();
      }, 1000)
    });
  }
  
  var promise2 = function() {
    return new Promise(function(resolve) {
      setTimeout(function() {
        console.log(2);
        resolve();
      }, 2000)
    });
  }
  
  promise1()
    .then(function() {
      return promise2(); // 此处返回一个 promise 实例
    })
    .then(function() { console.log('已完成');}, function() { console.log('已拒绝'); });
  ```

* 如果 x 为 Object 或 function**（不常见）**

  * 首先尝试执行 `x.then`
  * 如果取 `x.then` 的值时抛出异常错误 `e` ，则以 `e` 为据因拒绝 `promise`
  * 如果 `then` 是函数，将 `x` 作为函数的作用域 `this` 调用。传递2个回调函数作为参数，第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise` ：
    * 如果 `resolvePromise` 以值 `y` 为参数被调用，则运行 `[[Resolve]](promise, y)` 
    * 如果 `rejectPromise` 以据因 `r` 为参数被调用，则以据因 `r` 拒绝 `promise` 
    * 如果 `resolvePromise` 和 `rejectPromise` 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略其他的调用
    * 如果调用 `then` 方法抛出了异常 `e` 
      * 如果 `resolvePromise` 和 `rejectPromise` 已经被调用，则忽略
      * 否则以 `r` 为据因拒绝 `promise`
  * 如果取 `then` 不为函数，以 `x` 为参数将 `promise` 变为已完成状态

* 如果 `x` 不为对象或函数，以 `x` 为参数将 `promise` 变为已完成状态**（重要且常见）**

### 1.5 Promise 构造函数上的静态方法

#### 1.5.1 Promise.resolve

返回一个 promise 实例，并把它的状态设置为已完成，同时将他的结果作为传入 promise 实例的值

```javascript
var promise = Promise.resolve(123);
promise
  .then(function(val) {
    console.log('已完成', val);
  });
// 已完成 123
```

同样的，`promise.resolve` 的参数也可以处理对象、函数等内容，处理方式和上面规范中介绍的相同。

#### 1.5.2 Promise.reject

返回一个 promise 实例，并将它的状态设置为已拒绝，同时将他的结果作为原因传入 onRejected 函数

```javascript
var promise = Promise.reject(123);
promise
  .then(null, function(val) {
    console.log('已拒绝', val);
  });
// 已拒绝 123
```

#### 1.5.3 Promise.all

返回一个 promise 实例，接受一个数组，里面含有多个 promise 实例，当所有的 promise 实例都成为已完成状态时，进入已完成状态，否则进入已拒绝状态。

```javascript
var promise1 = function() {
  return new Promise(function(resolve) {
    setTimeout(function() {
      console.log(1);
      resolve();
    }, 1000)
  });
}

var promise2 = function() {
  return new Promise(function(resolve) {
    setTimeout(function() {
      console.log(2);
      resolve();
    }, 2000)
  });
}

Promise.all([promise1(), promise2()])
  .then(function() {
    console.log('全部 promise 均已完成');
  });
```

注意，此时多个 promise 是同时进行的，也就是在上面的例子中，等待 1s 打印 1 之后，再等待 1s 就会打印 2 和「全部 promise 均已完成」。

#### 1.5.4 Promise.race

返回一个 promise 实例，接受一个数组，里面含有多个 promise 实例，当有一个 promise 实例状态改变时，就进入该状态且不可改变。这里所有的 promise 实例为竞争关系，只选择第一个进入改变状态的 promise 值。

```javascript
var promise1 = function() {
  return new Promise(function(resolve) {
    setTimeout(function() {
      console.log(1);
      resolve(1);
    }, 1000)
  });
}

var promise2 = function() {
  return new Promise(function(resolve) {
    setTimeout(function() {
      console.log(2);
      resolve(2);
    }, 2000)
  });
}

Promise.race([promise1(), promise2()])
  .then(function(val) {
    console.log('有一个 promise 状态已经改变', val);
  });
```

### 1.6 实现一个简单的 promise

### 1.7 ES6/ESNext 中的generator/async await简介

## 2 JS中的模块化

## 3 CommonJS 规范初探

## 4 适合WEB开发的AMD模块化规范

## 5 能同时被CommonJS规范和AMD规范加载的UMD模块

## 6 ES Module规范

## 7 后模块化时代

### 7.1 打包工具初探