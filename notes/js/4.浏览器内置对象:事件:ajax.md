# 【JS内功修炼】浏览器内置对象/事件/ajax

## 浏览器内置对象/事件/ajax

### 1 Window浏览器内置对象

浏览器是一个 JS 的运行环境，它基于 JS 解析器的同时，增加了许多环境相关的内容。用一张图表示各个环境和 JS 解析器的关系如下：

![各个环境和JS解析器的关系](../../img/各种规范之间的关系.png)

我们把常见的，能够用 JS 这门语言控制的内容称为一个 JS 的运行环境。常见的运行环境有 Node.js、浏览器、小程序、一些物联网设备等等。所有的运行环境都必须有一个 JS 的解释器，在解释器层面符合 ECMAScript 规范，定义了 JS 本身语言层面的东西。比如：关键字、语法等等。

在每个环境中，也会基于 JS 开发一些当前环境中的特性，例如 Node.js 中的 global 对象，process 对象；浏览器环境中的 window 对象，document 对象等等，这些属于运行环境在 JS 基础上的内容。

这也就解释了为什么在 node.js 和浏览器中都能使用数组，函数，但是只能在 node.js 使用 require 加载模块，而不能在浏览器端使用的原因，因为 require 是 node.js 特有的运行环境中的内容。

#### 1.1 Window

window 是在浏览器中代表全局作用域，所有的全局作用域下声明的变量和内容最终都会变成 window 对象下的属性。比如：

```javascript
var num = 123;
console.log(window.123); // 123
```

访问未声明的变量时，如果直接访问则会报错，而如果使用 window 进行访问，就像通过对象访问那样，会返回 undefined。

```javascript
var name = oldName; // 报错
var name2 = window.oldName; // undefined
```

##### 1.1.1 setTimeout 和 setInterval

setTimeout 和 setInterval 他们都可以接受2个参数，第一个参数是一个**回调函数**，第二个参数是**等待执行的时间**。在等待时间结束之后，就会将回调函数放到 event loop 中进行执行。它们都返回一个 id，传入 clearTimeout 和 clearInterval 能够清除这次的定时操作。

```javascript
var id = setTimeout(function() {
  console.log('hello world');
}, 2000);
clearTimeout(id);
```

可视化工具网站：<http://latentflip.com/loupe/>

重点：如果此时队列中没有内容，则会立即执行此回调函数，如果此时队列中有内容的话，则会等待内容执行完成之后再执行此函数。（所以即使等待时间结束，也不是立刻执行这个回调函数的！）

因为 setTimeout 执行时间的不可确定性，所以大部分时候，我们会使用 setTimeout 来模拟 setInterval

##### 1.1.2 alert、confirm、prompt 等交互相关 API

alert 会弹出一个警告框，而 confirm 和prompt 则可以与用户交互，confirm 会弹出一个确认框，最终返回 true（用户点击确定）或返回 false（用户点击取消），而 prompt 用户则可以输入一段文字，最终返回用户输入的结果。

#### 1.2 Location

##### 1.2.1 属性

* hash:	返回一个 URL 的锚部分
* host:	返回一个 URL 的主机名和端口
* hostname:	返回一个 URL 的主机名
* href:	当前 url
* pathname:	返回 URL 路径名
* port:	返回一个 URL 服务器使用的端口号
* protocal:	返回一个 URL 协议
* search:	返回一个 URL 的查询部分

##### 1.2.2 方法

* reload:	重新载入当前页面
* replace:	用新的页面替换当前页面

#### 1.3 Document

##### 1.3.1 方法：选择器

选择器是考察浏览器相关知识点的重中之重，一般会结合实际场景进行考察。

`getElementById`，`getElementsByClassName`，`getElementsByTagName` 等早期规范定义的 API，还有新增的`querySelector`，`querySelectorAll` 等新规范增加的选择器。

重点：`getElementsByTagName` 等返回多个 node 节点的函数返回值并不是数组，而是浏览器实现的一种数据结构。

##### 1.3.2 方法：创建元素

`document.createElement` 能够创建一个 dom 元素，在新增多个元素时，可以先在内存中拼接出所有的 dom 元素后一次插入。

```javascript
var fruits = ['Apple', 'Orange', 'Banana', 'Melon'];
var fragment = document.createDocumentFragment();
fruits.forEach(fruit => {
  const li = document.createElement('li');
  li.innerHTML = fruit;
  fragment.appendChild(li);
});
document.body.appendChild(fragment);
```

##### 1.3.3 属性

* title:	`document.title` 可以设置或返回当前页面标题
* domain:	展示当前网站的域名
* url:	当前网站的链接
* anchors:	返回所有的锚点，带 name 属性的 a 标签
* forms:	返回所有的 form 标签集合
* images:	返回所有的 img 标签集合
* links:	返回所有带 href 属性的 a 标签

#### 1.4 Element

Element 元素的 nodeType 均为 1，大多数标签都是一个 Element 实例。

##### 1.4.1 属性

* tagName:	返回当前元素的标签名

##### 1.4.2 方法

* getAttribute:	获取当前节点属性的结果
* setAttribute:	设置当前节点属性

#### 1.5 Text 类型

Text 类型包含所有纯文本内容，它不支持子节点，同时他的 nodeType 均为 3

#### 1.6 History

History 对象包含用户（在浏览器窗口中）访问过的 URL。在 HTML5 中，history 还与客户端路由息息相关。

##### 1.6.1 属性

* length:	返回历史列表中的网址数

##### 1.6.2 方法

* back:	加载 history 列表中的前一个 URL
* forward:	加载 history 列表中的下一个 URL
* go:	加载 history 列表中的某个具体页面
* pushState:	替换地址栏地址，并且加入 history 列表，但并不会刷新页面
* replaceState:	替换地址栏地址，替换当前页面在 history 列表中的记录，并不刷新页面

### 2 事件

#### 2.1 定义事件

#### 2.2 事件捕获及冒泡

#### 2.3 事件对象

#### 2.4 事件委托

#### 2.5 一个通用的事件模型

### 3 ajax

#### 3.1 ES6 之后的 fetch API

#### 3.2 封装的通用 ajax 请求